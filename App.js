import React, { Component } from "react";
import { Provider } from "react-redux";
import {
  YellowBox,
  BackHandler,
  DeviceEventEmitter,
  Platform,
  View,
  Alert,
  AsyncStorage,
  ActivityIndicator,
  PushNotificationIOS
} from "react-native";
import { store, persistor } from "./src/Store";
import { PersistGate } from "redux-persist/integration/react";
import Route from "./src/Router";
import InitialApp from "./src/Controller/InitialController";
import { Actions } from "react-native-router-flux";
import { isSignedIn } from "./src/Controller/AuthUserController";
import PushNotification from "react-native-push-notification";
import BackgroundJob from "react-native-background-job";
import RegisterSocketChat from "./registerSocketChat";
import OneSignal from "react-native-onesignal"; // Import package from node modules
YellowBox.ignoreWarnings([
  "Warning: isMounted(...) is deprecated",
  "Module RCTImageLoader",
  "Setting a timer",
  "Warning: isMounted(...) is deprecated in plain JavaScript React classes. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
]);

// const backgroundJob = {
//   jobKey: "count",
//   job: () => {

//   }
// };

// BackgroundJob.register(backgroundJob);
PushNotification.configure({
  onNotification: function(notification) {
    // console.log('NOtify');
    Actions.chat();
    // required on iOS only (see fetchCompletionHandler docs: https://facebook.github.io/react-native/docs/pushnotificationios.html)
    if (Platform.OS == "ios") {
      notification.finish(PushNotificationIOS.FetchResult.NoData);
    }
  },
  requestPermissions: true
});

const registerSocketChat = new RegisterSocketChat();

store.subscribe(() => {
  const state = store.getState();
  const {
    AuthUserReducer: { token }
  } = state;
  registerSocketChat.clear();
  if (token) {
    // listen for operator text to user and push notification immediately.
    function callback(result) {
      if (!result) return;
      PushNotification.localNotification({
        title: `New message`,
        message: `${result.user.name}: ${result.text}`
      });
    }
    registerSocketChat.connect(token).listen(callback);
  }
});

// listen for token when login success

// var backgroundSchedule = {
//   jobKey: "count",
//   period: 1000,
//   allowWhileIdle: true
// };

// BackgroundJob.schedule(backgroundSchedule);
// function onNotificationOpened(notification) {
//   console.log("onNotificationOpened: ", notification);
// }
// NotificationsAndroid.setNotificationOpenedListener(onNotificationOpened);
const oneSignalAppID = "b3efb7be-85f6-4432-b194-67ed0e5616d0";
export default class App extends Component {
  constructor(props) {
    super(props);
    OneSignal.init(oneSignalAppID);
  }
  componentDidMount() {
    // PushNotification.localNotification({
    //   title: "Local notification",
    //   message: "This notification was generated by the app!"
    // });

    DeviceEventEmitter.removeAllListeners("hardwareBackPress");
    DeviceEventEmitter.addListener("hardwareBackPress", () => {
      try {
        isSignedIn().then(res => {
          if (res) {
            Actions.home();
          } else {
            Actions.login();
          }
        });

        return true;
      } catch (err) {
        // Alert(err);
        BackHandler.exitApp();
        // return false;
      }
    });

    new InitialApp();
  }

  randerLoading = () => {
    return (
      <View
        style={{
          flex: 1,
          flexDirection: "column",
          justifyContent: "space-between"
        }}
      >
        <ActivityIndicator size="large" style={{ flex: 2 }} />
      </View>
    );
  };

  render() {
    return (
      <Provider store={store}>
        <PersistGate loading={this.randerLoading()} persistor={persistor}>
          <Route />
        </PersistGate>
      </Provider>
    );
  }
}
